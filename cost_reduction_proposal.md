# 運用コスト削減提案レポート

**作成日**: 2026年1月9日  
**作成者**: Manus AI

---

## エグゼクティブサマリー

本レポートでは、ポートフォリオアドバイザーWebサイトの運用コストが高い原因を特定し、コスト削減のための具体的な提案を行います。分析の結果、現在のシステムは**1日あたり約8,600回のAPI呼び出し**を行っており、これが高コストの主要因であることが判明しました。提案する最適化を実施することで、**API呼び出し回数を95%削減**し、運用コストを大幅に低減できます。

---

## 1. 現状分析：コスト発生の原因

### 1.1 API呼び出し回数の内訳

現在のシステムでは、各エンドポイントで以下のAPI呼び出しが発生しています。

| エンドポイント | API呼び出し回数/リクエスト | 説明 |
|---------------|---------------------------|------|
| market.getAnalysis | 6回 | SPY, VIX, TNX, IRX, HYG, LQD |
| portfolio.getRecommendations | 114回 | 100銘柄 + 14 ETF |
| backtest.run | 100回 | 100銘柄のヒストリカルデータ |

### 1.2 1日あたりの想定API呼び出し回数

想定アクセス数（ホーム100回、ポートフォリオ50回、バックテスト20回）に基づく試算は以下の通りです。

| ページ | アクセス数 | API呼び出し/回 | 合計 |
|--------|-----------|----------------|------|
| ホームページ | 100回 | 6回 | 600回 |
| ポートフォリオ | 50回 | 120回 | 6,000回 |
| バックテスト | 20回 | 100回 | 2,000回 |
| **合計** | **170回** | - | **8,600回/日** |

月間では**約258,000回**のAPI呼び出しが発生しています。

### 1.3 コスト発生の主要因

分析の結果、以下の4つの主要因が特定されました。

**第1位：ポートフォリオ推奨機能（全体の約70%）**

ポートフォリオ推奨機能は、100銘柄 + 14 ETF = 114回のAPI呼び出しを毎回実行しています。これが最大のコスト要因です。

**第2位：バックテスト機能（全体の約23%）**

バックテスト機能は、100銘柄のヒストリカルデータを毎回取得しています。同じ日付のバックテストでも、毎回APIを呼び出しています。

**第3位：キャッシュの不在**

現在のシステムにはキャッシュ機構がなく、同じデータを何度も取得しています。市場データは1日1回の更新で十分ですが、毎回リアルタイムで取得しています。

**第4位：並列処理による瞬間的な負荷**

100銘柄のデータを並列で取得するため、瞬間的に大量のAPI呼び出しが発生し、レート制限に抵触するリスクがあります。

---

## 2. コスト削減提案

### 2.1 提案1：サーバーサイドキャッシュの導入（削減効果：90-95%）

**概要**: 市場データをサーバーサイドでキャッシュし、同じデータへの重複リクエストを排除します。

**実装方法**:

```typescript
// キャッシュの有効期限設定
const CACHE_TTL = {
  marketAnalysis: 5 * 60 * 1000,    // 5分
  portfolioData: 60 * 60 * 1000,    // 1時間
  backtestData: 24 * 60 * 60 * 1000 // 24時間（過去データは変わらない）
};

// メモリキャッシュの実装例
const cache = new Map<string, { data: any; expiry: number }>();

function getCachedData(key: string): any | null {
  const cached = cache.get(key);
  if (cached && cached.expiry > Date.now()) {
    return cached.data;
  }
  return null;
}
```

**期待効果**:

| 指標 | 現在 | 導入後 | 削減率 |
|------|------|--------|--------|
| API呼び出し/日 | 8,600回 | 430回 | 95% |
| API呼び出し/月 | 258,000回 | 12,900回 | 95% |

### 2.2 提案2：定期バッチ処理への移行（削減効果：99%）

**概要**: 市場データの取得をリアルタイムから定期バッチ処理に変更します。

**実装方法**:

1. **毎日1回のバッチ処理**: 市場終了後（日本時間6:00頃）に全銘柄のデータを一括取得
2. **データベースへの保存**: 取得したデータをデータベースに保存
3. **APIからの読み取り**: ユーザーリクエスト時はデータベースから読み取り

```typescript
// cronジョブの設定例
// 毎日6:00 AMに実行
schedule.scheduleJob('0 6 * * *', async () => {
  await fetchAndStoreAllMarketData();
});
```

**期待効果**:

| 指標 | 現在 | 導入後 | 削減率 |
|------|------|--------|--------|
| API呼び出し/日 | 8,600回 | 約120回 | 99% |
| API呼び出し/月 | 258,000回 | 約3,600回 | 99% |

### 2.3 提案3：銘柄ユニバースの最適化（削減効果：50%）

**概要**: 100銘柄の全量取得から、段階的な取得に変更します。

**実装方法**:

1. **上位銘柄の優先取得**: まず上位20銘柄のデータを取得
2. **必要に応じて追加取得**: ユーザーが詳細を要求した場合のみ追加銘柄を取得
3. **過去の選定結果の活用**: 過去に選定された銘柄を優先的にキャッシュ

```typescript
// 段階的取得の実装例
const TOP_PRIORITY_SYMBOLS = SEIHAI_SYMBOLS.slice(0, 20);
const SECONDARY_SYMBOLS = SEIHAI_SYMBOLS.slice(20, 50);
const TERTIARY_SYMBOLS = SEIHAI_SYMBOLS.slice(50);

async function getPortfolioRecommendations(detailed: boolean = false) {
  // まず上位20銘柄を取得
  const topData = await fetchSymbols(TOP_PRIORITY_SYMBOLS);
  
  if (detailed) {
    // 詳細モードの場合は追加取得
    const secondaryData = await fetchSymbols(SECONDARY_SYMBOLS);
    // ...
  }
}
```

**期待効果**:

| 指標 | 現在 | 導入後 | 削減率 |
|------|------|--------|--------|
| ポートフォリオAPI呼び出し | 114回 | 34回 | 70% |
| バックテストAPI呼び出し | 100回 | 20回 | 80% |

### 2.4 提案4：クライアントサイドキャッシュの活用（削減効果：30-50%）

**概要**: ブラウザのローカルストレージやReact Queryのキャッシュを活用します。

**実装方法**:

```typescript
// React Queryのキャッシュ設定
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5分間はキャッシュを使用
      cacheTime: 60 * 60 * 1000, // 1時間キャッシュを保持
    },
  },
});
```

**期待効果**: 同一ユーザーの連続アクセスでAPI呼び出しを30-50%削減

---

## 3. 推奨実装順序

コスト削減効果と実装難易度を考慮し、以下の順序での実装を推奨します。

| 優先度 | 提案 | 削減効果 | 実装難易度 | 実装期間 |
|--------|------|----------|------------|----------|
| 1 | サーバーサイドキャッシュ | 95% | 低 | 1-2日 |
| 2 | クライアントサイドキャッシュ | 30-50% | 低 | 0.5日 |
| 3 | 銘柄ユニバースの最適化 | 50% | 中 | 2-3日 |
| 4 | 定期バッチ処理 | 99% | 高 | 3-5日 |

**推奨**: まず提案1（サーバーサイドキャッシュ）を実装することで、最小の労力で最大の効果（95%削減）を得られます。

---

## 4. 実装計画

### Phase 1: サーバーサイドキャッシュの導入（1-2日）

1. メモリキャッシュモジュールの作成
2. marketData.tsへのキャッシュ統合
3. portfolioSelection.tsへのキャッシュ統合
4. backtestService.tsへのキャッシュ統合
5. テストと検証

### Phase 2: クライアントサイドキャッシュの最適化（0.5日）

1. React QueryのstaleTime/cacheTime設定
2. ローカルストレージへの永続化（オプション）

### Phase 3: 銘柄ユニバースの最適化（2-3日）

1. 優先銘柄リストの定義
2. 段階的取得ロジックの実装
3. UIの調整（詳細表示ボタンの追加）

### Phase 4: 定期バッチ処理（3-5日）

1. バッチ処理スクリプトの作成
2. データベーススキーマの拡張
3. cronジョブの設定
4. APIエンドポイントの修正

---

## 5. 期待される成果

すべての提案を実装した場合の期待効果は以下の通りです。

| 指標 | 現在 | 最適化後 | 改善率 |
|------|------|----------|--------|
| API呼び出し/日 | 8,600回 | 約100回 | 99% |
| API呼び出し/月 | 258,000回 | 約3,000回 | 99% |
| レスポンス時間 | 5-10秒 | 0.5-1秒 | 90% |
| 運用コスト | 100% | 約1-5% | 95-99% |

---

## 6. 結論

現在のシステムは、キャッシュ機構がなく、毎回リアルタイムでAPIを呼び出しているため、運用コストが高くなっています。サーバーサイドキャッシュの導入により、最小の実装コストで95%のAPI呼び出し削減が可能です。

まずはPhase 1（サーバーサイドキャッシュ）の実装を推奨します。これにより、ユーザー体験の向上（レスポンス時間の短縮）と運用コストの大幅削減を同時に達成できます。

---

*本レポートは現在のシステム構成に基づいて作成されました。実際の削減効果は、アクセスパターンやキャッシュヒット率によって変動する可能性があります。*
